////
//// Created by owlet on 23.11.2019.
////
//
//#include <omp.h>
//#include <iostream>
//#include <stdlib.h>
//#include <stdio.h>
//#include <process.h>
//#include <time.h>
//#include <locale.h>
//#include <windows.h>
//#include <thread>
//
//using namespace std;
//
//FILE *stream;                                               // Файловый поток.
///* Процедура printTimeStamp для определения и вывода текущего времени.   */
///* Получить текущее время, вывести его на экран и записать в файл        */
//
//void printTimeStamp()
//{
//    SYSTEMTIME timeStamp;                          // Текущее время.
//    GetLocalTime (&timeStamp);              // Определить текущее время.
//    printf("%02d:%02d:%02d.%03d",           // Вывести текущее время на экран.
//           timeStamp.wHour, timeStamp.wMinute,
//           timeStamp.wSecond, timeStamp.wMilliseconds);
//    fprintf(stream, "%02d:%02d:%02d.%03d",  // Записать текущее время в файл.
//            timeStamp.wHour, timeStamp.wMinute, timeStamp.wSecond, timeStamp.wMilliseconds);
//}
//
///* Процедура writer, моделирующая действия писателей.                    */
///*   storage - хранилище, в котором писатель сохраняет сообщение;        */
///*   totalWriters - количество писателей;                                */
///*   activeReaders - количество читателей, работающих с хранилищем       */
///*     в настоящий момент;                                               */
///*   writeLock - замок для взаимоблокировки писателей;                   */
///*   readLock - переменная для блокировки читателей.                     */
///* Глобальные переменные:                                                */
///*   stream - файловый поток.                                            */
///* Алгоритм работы:                                                      */
///* 1) Создать параллельные потоки в количестве totalWriters.             */
///* 2) Определить номер threads текущего потока-писателя.                 */
///* 3) Выполнять в бесконечном цикле:                                     */
///*    3.1) Выждать случайное время (в диапазоне от 3 до 18 секунд).      */
///*    3.2) Вывести на экран и записать в файл сообщение о том,           */
///*         что текущий процесс обратился к хранилищу.                    */
///*    3.3) Запретить доступ к хранилищу другим писателям. При этом если  */
///*         другой писатель уже запросил доступ к хранилищу, то:          */
///*           - вывести на экран и записать в файл                        */
///*             информационное сообщение об этом;                         */
///*           - заблокировать текущий поток (выполняется с помощью        */
///*             попытки повторно установить замок writeLock).             */
///*    3.4) Запретить доступ к хранилищу новым читателям.                 */
///*    3.5) Если в данный момент с хранилищем работают читатели, то:      */
///*           - вывести на экран и записать в файл                        */
///*             информационное сообщение об этом;                         */
///*           - дождаться окончания работы всех читателей.                */
///*    3.6) Вывести на экран и записать в файл сообщение о том,           */
///*         что текущий процесс получил доступ к хранилищу.               */
///*    3.7) Выждать 3 секунды.                                            */
///*    3.8) Сгенерировать случайное значение и записать его в хранилище.  */
///*    3.9) Вывести на экран и записать в файл сообщение о том,           */
///*         что текущий процесс записал сообщение в хранилище             */
///*         и завершил работу.                                            */
///*    3.10) Разрешить доступ к хранилищу читателям.                      */
///*    3.11) Разрешить доступ к хранилищу писателям                       */
///*          (снять замок writeLock).                                     */
//
//void writer(int& storage, int totalWriters, int& activeReaders, omp_lock_t& writeLock, bool& readLock)
//{
//#pragma omp parallel num_threads(totalWriters) // Создать параллельные
//    {                                       //  потоки.
//        bool flag;                       // Переменная используется для того, чтобы
//        //  подавить вывод повторных сообщений
//        //  на экран и в файл, если писатель
//        //  ожидает, пока читатели завершат
//        //  работу с хранилищем.
//        int writerNumber = omp_get_thread_num();        // Определить номер
//        //  потока-писателя.
//        while(true)                                    // Выполнять в бесконечном
//        {                                              //  цикле.
//            flag = false;
//            this_thread::sleep_for(rand() * writerNumber % 15000 + 3000);
//            // Выждать случайное время от 3 до 18 секунд
//            //  (множитель writerNumber нужен для того,
//            //  чтобы результат различался
//            //  для разных потоков).
//#pragma omp critical                                  // Вывести информацию на экран и в файл.
//            {
//                printTimeStamp();
//                printf(": Писатель %d обратился к хранилищу...\n", writerNumber);
//                fprintf(stream, ": Писатель %d обратился к хранилищу...\n",
//                        writerNumber);
//            }
//            if (!omp_test_lock(&writeLock))         // Если к хранилищу уже запросил
//            {                                       //  доступ другой писатель, то
//#pragma omp critical                                               //  вывести информацию на экран
//                {                                 //  и в файл.
//                    printf("Другой писатель обратился к хранилищу раньше. ");
//                    printf("Писатель %d ожидает.\n", writerNumber);
//                    fprintf(stream,"Другой писатель обратился к хранилищу раньше. ");
//                    fprintf(stream, "Писатель %d ожидает.\n", writerNumber);
//                }
//                omp_set_lock(&writeLock);         // Заблокировать текущий поток.
//            } // if (!omp_test_lock(&writeLock))
//            readLock = true;                        // Запретить доступ к хранилищу
//            //  новым читателям.
//            while(activeReaders != 0)         // Дождаться окончания работы
//            {                          //  с хранилищем текущих читателей.
//                if (!flag)          // Если информация ещё не выводилась,
//                {                   //  то вывести её на экран и в файл.
//#pragma omp critical
//                    {
//                        printf("Писатель %d ожидает, пока ", writerNumber);
//                        printf("активные читатели закончат работу с хранилищем.\n");
//                        fprintf(stream,"Писатель %d ожидает, пока ", writerNumber);
//                        fprintf(stream,"активные читатели закончат работу с хранилищем.\n");
//                    }
//                } //if (!flag)
//                flag = true;        // Отметить факт вывода информации.
//                this_thread::sleep_for(chrono::milliseconds(100));         // Выждать 0,1 секунды.
//            } // while(activeReaders != 0)
//#pragma omp critical                                        // Вывести информацию на экран и в файл.
//            {
//                printTimeStamp();
//                printf(": Писатель %d получил доступ к хранилищу.\n", writerNumber);
//                fprintf(stream,": Писатель %d получил доступ к хранилищу.\n", writerNumber);
//            }
//            Sleep(3000);                      // Выждать 3 секунды.
//            storage = rand() + writerNumber;  // Сгенерировать сообщение
//            //  и записать его в хранилище.
//#pragma omp critical                                        // Вывести информацию на экран и в файл.
//            {
//                printTimeStamp();
//                printf(": Писатель %d записал в хранилище ", writerNumber);
//                printf("сообщение %d и закончил работу.\n", storage);
//                fprintf(stream,": Писатель %d записал в хранилище ", writerNumber);
//                fprintf(stream,"сообщение %d и закончил работу.\n", storage);
//            }
//            readLock = false;          // Разрешить доступ к хранилищу читателям.
//            omp_unset_lock(&writeLock);       // Разрешить доступ к хранилищу писателям.
//        } // while(true)
//    } // #pragma omp parallel
//}
///* Процедура reader, моделирующая действия читателей.                    */
///* Принимаемые параметры:                                                */
///*   storage - хранилище, из которого читатель получает сообщение;       */
///*   totalReaders - количество читателей;                                */
///*   activeReaders - количество читателей, работающих с хранилищем       */
///*     в настоящий момент;                                               */
///*   readLock - переменная для блокировки читателей.                     */
///* Алгоритм работы:                                                      */
///* 1) Создать параллельные потоки в количестве totalReaders.             */
///* 2) Определить номер threads текущего потока-читателя.                 */
///* 3) Выполнять в бесконечном цикле:                                     */
///*    3.1) Выждать случайное время (в диапазоне от 3 до 15 секунд).      */
///*    3.2) Вывести на экран и записать в файл сообщение о том,           */
///*         что текущий процесс обратился к хранилищу.                    */
///*    3.3) Если доступ к хранилищу для читателей заблокирован, то:       */
///*           - вывести на экран и записать в файл                        */
///*             информационное сообщение об этом;                         */
///*           - дождаться снятия блокировки.                              */
///*    3.4) Вывести на экран и записать в файл сообщение о том,           */
///*         что текущий процесс получил доступ к хранилищу.               */
///*    3.5) Увеличить значение переменной activeReaders на единицу.       */
///*    3.6) Выждать 3 секунды.                                            */
///*    3.7) Вывести на экран и записать в файл сообщение о том,           */
///*         что текущий процесс получил сообщение из хранилища            */
///*         и завершил работу.                                            */
///*    3.8) Уменьшить значение переменной activeReaders на единицу.       */
//
//void reader(int& storage, int totalReaders, int& activeReaders,bool& readLock)
//{
//#pragma omp parallel num_threads(totalReaders) // Создать параллельные
//    {                                       //  потоки.
//        bool flag;                        // Переменная используется для того, чтобы
//        //  подавить вывод повторных сообщений
//        //  на экран и в файл, если писатель
//        //  ожидает, пока читатели завершат
//        //  работу с хранилищем.
//        int readerNumber = omp_get_thread_num(); // Определить номер
//        //  потока-читателя.
//        while(true)                             // Выполнять в бесконечном
//        {                                       //  цикле.
//            flag = false;
//            Sleep(rand() * readerNumber % 12000 + 3000);
//            // Выждать случайное время от 3 до 15 секунд
//            //  (множитель readerNumber нужен для того,
//            //  чтобы результат различался
//            //  для разных потоков).
//#pragma omp critical                                  // Вывести информацию на экран и в файл.
//            {
//                printTimeStamp();
//                printf(": Читатель %d обратился к хранилищу...\n", readerNumber);
//                fprintf(stream,": Читатель %d обратился к хранилищу...\n", readerNumber);
//            }
//            while(readLock == true)    // Дождаться доступа к хранилищу.
//            {
//                if (!flag)   // Если информация ещё не выводилась,
//                {
//#pragma omp critical                                  //  то вывести её на экран и в файл.
//                    {
//                        printf("Доступ к хранилищу заблокирован. ");
//                        printf("Читатель %d ожидает.\n", readerNumber);
//                        fprintf(stream,"Доступ к хранилищу заблокирован. ");
//                        fprintf(stream,"Читатель %d ожидает.\n", readerNumber);
//                    }
//                }
//                flag = true; // Отметить факт вывода информации.
//                Sleep(100);  // Выждать 0,1 секунды.
//            }
//#pragma omp critical                                  // Вывести информацию на экран и в файл.
//            {
//                printTimeStamp();
//                printf(": Читатель %d получил доступ к хранилищу.\n", readerNumber);
//                fprintf(stream,": Читатель %d получил доступ к хранилищу.\n", readerNumber);
//            }
//#pragma omp atomic
//            activeReaders++;           // Увеличить количество активных читателей.
//            Sleep(3000);               // Выждать 3 секунды.
//#pragma omp critical                                  // Вывести информацию на экран и в файл.
//            {
//                printTimeStamp();
//                printf(": Читатель %d прочитал из хранилища ", readerNumber);
//                printf("сообщение %d и закончил работу.\n", storage);
//                fprintf(stream,": Читатель %d прочитал из хранилища ", readerNumber);
//                fprintf(stream,"сообщение %d и закончил работу.\n", storage);
//            }
//#pragma omp atomic
//            activeReaders--;           // Уменьшить количество активных читателей.
//        } // while(true)
//    } // #pragma omp parallel
//}
///* Выполняемые действия:                                                 */
///* 1) Определить файл для вывода информации.                             */
///* 2) Инициализировать замок для взаимоблокировки писателей.             */
///* 3) Включить обработку вложенных директив OpenMP.                      */
///* 4) Запросить у пользователя следующие исходные данные:                */
///*    - количество потоков-писателей totalWriters;                       */
///*    - количество потоков-читателей totalReaders.                       */
///* 5) Создать два параллельных потока и в одном из них вызвать           */
///*    процедуру моделирования писателей, а в другом - процедуру          */
///*    моделирования читателей.                                           */
//int main()
//{
//    setlocale (LC_ALL,"Russian");
//    srand (time(NULL));
//    int storage = 0;                        // Хранилище.
//    int totalWriters = 0,                          // Количество писателей.
//            totalReaders = 0;                 // Количество читателей.
//    int activeReaders = 0;                  // Количество читателей, работающих с хранилищем
//    //  в настоящий момент.
//    omp_lock_t writeLock;                          // Замок для блокировки писателей.
//    bool readLock = false;                  // Переменная для блокировки читателей:
//    //  true - чтение запрещено;
//    //  false - чтение разрешено.
//    stream = fopen("log.txt", "w");       // Определить файл для вывода информации.
//    omp_init_lock(&writeLock);               // Инициализировать замок.
//    omp_set_nested(true);                          // Включить обработку вложенных директив OpenMP.
//
//    /* Запросить у пользователя исходные данные. */
//    printf ("Лабораторная работа N 6.\n");
//    printf ("Программная реализация задачи \"Писатели-читатели\".\n\n");
//    printf ("Введите количество писателей: ");
//    cin >> totalWriters;
//    printf ("Введите количество читателей: ");
//    cin >> totalReaders;
//    printf ("\nМоделирование началось. Для завершения работы нажмите Ctrl+C.\n");
//#pragma omp parallel sections                  // Создать два параллельных потока.
//    {
//#pragma omp section                            // Вызвать процедуру моделирования
//        {                                 //  писателей в первом потоке.
//            writer(storage, totalWriters, activeReaders, writeLock, readLock);
//        }
//#pragma omp section                            // Вызвать процедуру моделирования
//        {                                 //  читателей во втором потоке.
//            reader(storage, totalReaders, activeReaders, readLock);
//        }
//    }
//    return 0;
//}